[Comms]
We probably need to upgrade to msgpack so we can support nulls/infs

[General]
Endpoints:
* trim_transparency file
* resize_image file out-file [mode]

[OpenCloud APIs MCP]
Use env to get API KEY
Allow ENV to configure: GroupId, ExperienceId, and maybe PlaceId
Start hooking up all known open cloud APIs
Endpoints:
* upload_asset file [name] [assetid for replacing]
* search_asset
 - Searches the group for a given asset
* "place configurations"
* "experience configurations"
* "luau code execution"

[Reference Paths]
During a session we can utilize an auxilary instance ref uuid via GetDebugId(0)
This string can accompany paths with a format like (its not always a number tmk):
ReplicatedStorage/SomeInstance~1523
These are only stable per studio session, so they should be included in metadata responses about instances
This is helpful for editing instance trees with duplicated children/ambiguous paths

[Instance codec]
Need to develop codec for transmitting instances
Use msgpack for transmission
Duplicate paths handled by naming `{inst.Name}~{inst.GetDebugId(0)}`
Grab MaximumADHD's reflection json via github. use in Rust+Plugin. create luau/rust types for it.
{
  "Name": "InstanceName",
  "ClassName": "Part",
  "UniqueId": "GetDebugId(0) output, e.g. 1234af",
  "Properties": {
    "Text": "Hello",
    "Shape": {"Enum.PartType": "Block"},
    "Anchored": true,
    "Size": {"Vector3": [4, 1, 2]},
    "Color": {"Color3": [0.5, 0.7, 0.0]},
    "CFrame": {"CFrame": [[0,5,0], [1,0,0,0,1,0,0,0,1]]},
    "Material": {"Enum.Material": "SmoothPlastic"},
    "Attachment0": {"Reference": "Some/Path[~123]"},
    "Attachment1": null,
    "Health": 37,
    "ViewDistance": {"number": "inf"}
  },
  "Attributes": {
    // Same semantics as Properties with what Attributes actually support
  },
  "Tags": [ "Tag" ],
  "Children": {
    // If any children share a name, ALL of that name get ~ suffix
    "Handle~a1b2": {
      // ...
    },
    "Handle~f31a": {
      // ...
    }
  }
}

[Studio Plugin MCP]
* Ensure that every function definition has typed parameters and typed results. you can ignore functions which have no return value, those are fine.
* Utilize ChangeHistoryService
* Upgrade to msgpack for rust<->plugin comms
* Should utilize msgpack for encoding scheme
* Handle inf/nan values somehow
Endpoints:
* run_code command [DONE]
 - Runs arbitrary Luau in Studio edit mode, returns print output
* get_console_output [DONE]
 - Returns Studio output window contents
* get_studio_mode [DONE]
 - Returns one of: start_play, run_server, stop
* start_stop_play mode [DONE]
 - mode: start_play | run_server | stop
* run_script_in_play_mode code [mode] [timeout] [DONE]
 - Runs in play/server mode, auto-stops, returns structured result
 - Result: { success, value, error, logs, errors, duration, isTimeout }
* insert_model query [DONE]
 - Searches marketplace, inserts into workspace, returns model name
* get_instance_tree paths [depth]
 - outputs our instance codec scheme noted above
* set_properties paths data
 - msgpack data so it supports nulls/infs, leaves unreferenced values
 - supports refs
 - probably respond with current instance state?
* get_properties paths
 - msgpack data so it supports nulls/infs, leaves unreferenced values
* add_tags paths tags
 - probably respond with current instance state?
* remove_tags paths tags
 - probably respond with current instance state?
* get_tags paths
* get_attributes paths
* set_attributes paths data
 - msgpack data so it supports nulls/infs, leaves unreferenced values
 - probably respond with current instance state?
* delete_instances paths
* set_parent paths parentPath
 - returns paths
* create_instance paths classname
 - could include optional properties, tags, and attributes
 - probably respond with current instance state?
* take_screenshot [paths]
 - Path could be a ScreenGui, a Part, Model - anything. Will intelligently crop.
 - Encode as PNG over wire
 - Output to agent as base64
* get_selections
* set_selections paths
* get_place_info
 - UniverseID, PlaceId, PlaceName, time info, StudioService, etc...
* undo [times]
* redo [times]
* rename_instance paths newName
 - returns paths
* get_script_source paths
* set_script_source paths source
* search_script_source filter [includes] [excludes]
 - model after grep
* query query [parents]
 - SEE: https://create.roblox.com/docs/reference/engine/classes/Instance#QueryDescendants
* publish_place <target placeid, defaults to our placeid>
* docs ClassNames
 - returns roblox docs given a classname https://github.com/Roblox/creator-docs/tree/main/content/en-us/reference/engine/classes
 - we could probably just include this as a Skill on how to browse the roblox docs git
* schema ClassNames
 - includes property info with inheritence info, defaults, enum options, hierarchy
* clone Paths Parent
 - should send back the resulting path
* transform_parts paths cframe [pivot] [shallow]
 - applies both rotation/translation in one
* translate_parts paths vector3 [shallow]
* rotate_parts paths angle-vector3 [pivot] [shallow]
* scale_parts paths vector3 [pivot] [shallow]
* translate_frame paths udim2
* scale_frame paths vector2
* rotate_frame paths degree
* get_clipboard
* set_clipboard
* ability to copy/paste from other studio instances
 - we could accomplish this with SerializationService .rbxm's
 - i'm not sure this would retain references to things like SoundGroup, etc.
* enabling/disabling physics model view
 - in general we should expose a ton of those studio settings
* statistics
 - instance count, performance, etc
* access to profiler?
* undo via ChangeHistoryService
* redo via ChangeHistoryService
* history via ChangeHistoryService
* get_script_history
* open_place placeid

[Cookie APIs MCP]
Use that one library to automatically fetch the roblox studio cookie
use that for any other endpoints which opencloud doesnt currently support
Endpoints:
* placeid <-> gameid
* place information
* game information
* searching for games
* list games in group
* group information
* user information
* search catalog
* search users
* search toolbox
* toolbox assets

[Luau Code Execution]
We can use OpenCloud to perform remote luau code execution
This can be helpful for uploading assets which OpenCloud doesnt support directly
or even running code in roblox games in a headless mode.

[CI]
Setup automated testing of rust code
Setup automated TestEZ for the Lua code
Setup automated selene checking for the lua code
Setup automatic building of the plugin

[websocket]
Swap to websockets for lower latency, perform tasks async so it can have like 10+ queries going at the same time

[merging]
we need to do a cursor style code merging/accept UI in roblox studio when we do this
this would eliminate needing cursor at all, and you would just be using Claude desktop app + roblox studio.

[CSG]
We will want to support CSG in some way

[Multi-studio support]
How are we going to accomplish this?

[linter errors]
how in the world are we going to do linter errors? those are needed context.
